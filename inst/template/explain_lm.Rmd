---
title: "Explain Dx Gap"
output: html_document
date: "`r Sys.Date()`"
params:
  dm: dm
  data_tbl: data_tbl
  year: year
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(recipes)
library(ggplot2)
pkgload::load_all()
knitr::opts_chunk$set(
  comment = NA,
  echo = FALSE, 
  cache = FALSE, 
  fig.align = "center", 
  fig.fullwidth = TRUE,
  fig.height = 10,
  message = FALSE, 
  warning = FALSE
)
set.seed(2023)
```

```{r params}
year <- params$year
data_tbl <- params$data_tbl
```

The chosen year is `r params$year`.

```{r eval=FALSE}
df_lst <- load()
dm <- build_dm(df_lst, year = 2019)
data_tbl <- build_tbl(dm, vars = dxgap_constants$tb_vars)
```


```{r data}
tbl <- 
  data_tbl |> 
  compute_dx_gap() |> 
  mutate(is_hbc = forcats::as_factor(is_hbc)) |> 
  select(-any_of(c("year", "country")))
```

```{r spending}
tbl_split <- rsample::initial_split(tbl)
tbl_train <- rsample::training(tbl_split)
tbl_test <- rsample::testing(tbl_split)
```

```{r cv}
tbl_cv <- rsample::vfold_cv(tbl_train)
```

```{r lm}
lm_model <-
  parsnip::linear_reg(mode = "regression") %>%
  parsnip::set_engine("lm")
```

```{r combo}
models <- list(lm = lm_model)
# TODO: fine tune neighbors
preproc <- tibble::lst(
  simple = get_recipe(
    tbl, 
    neighbors = 5, 
    threshold = 0.25,
    impute_vars = c("gdp", "e_inc_num", "pop_total")
  ),
  log = get_log_recipe(simple),
  norm = get_normalize_recipe(simple),
  just_hbc = get_is_hbc_recipe(simple)
)
```

```{r set}
linear_models <- 
   workflowsets::workflow_set(
      preproc = preproc,
      models = models,
      cross = TRUE
   ) 
```

```{r fit}
wset <- 
  workflowsets::workflow_map(
    linear_models, 
    verbose = TRUE,
    metrics = yardstick::metric_set(yardstick::rmse, yardstick::rsq),
    fn = "fit_resamples",
    resamples = tbl_cv
  )
```

## Model ranking

```{r rank}
rank <- 
  workflowsets::rank_results(wset, rank_metric = "rmse", select_best = TRUE) |> 
  select(rank, wflow_id, model, .metric, mean) |> 
  filter(.metric == "rmse")
rank |> 
  gt::gt()
```

```{r assess, fig.height=5}
autoplot(wset) + theme_minimal()
```

```{r best}
tune_res <- 
  workflowsets::extract_workflow_set_result(
    wset, 
    id = rank$wflow_id[[1]]
  ) 
```

```{r finalize}
ids <- rank$wflow_id
wfs <- purrr::map(ids, ~ workflowsets::extract_workflow(wset, id = .x))
final_fit_wfs <- purrr::map(wfs, ~ fit(object = .x, data = tbl_train))
```

## Assumptions

```{r check-assumptions}
lm_obj <- purrr::map2(
  final_fit_wfs, 
  ids, 
  ~ workflowsets::extract_fit_parsnip(x = .x, id = .y)
)

lm_fit_obj <- purrr::map(lm_obj, ~ purrr::pluck(.x, "fit"))

plot_check <- purrr::map(
  lm_fit_obj,
  ~ performance::check_model(
    .x, 
    check = c("linearity", "normality", "qq", "outliers"),
    theme = "ggplot2::theme_minimal"
  )
) |> 
  purrr::set_names(nm = rank$wflow_id)
plot_check
```

```{r vif, fig.height=5}
check_vif <- purrr::map(lm_fit_obj, ~ performance::check_collinearity(.x))
purrr::map(check_vif, plot) |> 
  purrr::set_names(nm = rank$wflow_id) |> 
  purrr::map(.f = ~ .x + theme(axis.text.x = element_text(angle = 90)))
```

## Parameters

```{r coeff-viz, fig.height=4}
coeff <- 
  final_fit_wfs |> 
  purrr::map(broom::tidy) |> 
  purrr::set_names(nm = rank$wflow_id)
params_plot <- purrr::map(
  coeff,
  function(x) { 
    x |> 
    mutate(is_under_0.05 = if_else(p.value <= 0.05, TRUE, FALSE)) |> 
    mutate(is_under_0.05 = forcats::fct_relevel(
      as.character(is_under_0.05), 
      c("TRUE", "FALSE"))
    ) |> 
    mutate(term = forcats::fct_relevel(term, sort)) |> 
    ggplot(aes(term, estimate, color = is_under_0.05)) +
    geom_point() +
    geom_pointrange(aes(ymin = estimate - std.error, ymax = estimate + std.error)) +
    coord_flip() +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5), 
      axis.text.y = element_text(size = rel(1.25))
    )
  }
)
params_plot
```
