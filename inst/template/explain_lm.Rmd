---
title: "Explain Dx Gap"
output: html_document
date: "`r Sys.Date()`"
params:
  dm: dm
  data_tbl: data_tbl
  year: year
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(recipes)
library(ggplot2)
pkgload::load_all()
knitr::opts_chunk$set(
  echo = FALSE, 
  cache = FALSE, 
  fig.align = "center", 
  fig.fullwidth = TRUE,
  fig.height = 10,
  message = FALSE, 
  warning = FALSE
)
set.seed(2023)
```

```{r params}
year <- params$year
data_tbl <- params$data_tbl
```

The chosen year is `r params$year`.

```{r eval=FALSE}
df_lst <- load_dx()
dm <- build_dm(df_lst, year = 2019)
data_tbl <- build_tbl(dm, vars = dxgap_constants$tb_vars)
```


```{r data}
tbl <- 
  data_tbl |> 
  compute_dx_gap() |> 
  mutate(is_hbc = forcats::as_factor(is_hbc)) |> 
  select(-any_of(c("year", "country")))
```

```{r spending}
tbl_split <- rsample::initial_split(tbl)
tbl_train <- rsample::training(tbl_split)
tbl_test <- rsample::testing(tbl_split)
```

```{r cv}
tbl_cv <- rsample::vfold_cv(tbl_train)
```

```{r lm}
lm_model <-
  parsnip::linear_reg(mode = "regression") %>%
  parsnip::set_engine("lm")
```

```{r combo}
models <- list(lm = lm_model)
# TODO: fine tune neighbors
preproc <- tibble::lst(
  simple = get_recipe_tb(
    tbl, 
    neighbors = 5, 
    threshold = 0.25,
    impute_vars = c("gdp", "e_inc_num", "pop_total")
  ),
  log_pop_total = get_log_recipe_tb(simple),
  norm_pop_total = get_normalize_recipe_tb(simple),
  is_hbc_pop_total = get_is_hbc_recipe_tb(simple)
)
```

```{r set}
linear_models <- 
   workflowsets::workflow_set(
      preproc = preproc,
      models = models,
      cross = TRUE
   ) 
```

```{r fit}
wset <- 
  workflowsets::workflow_map(
    linear_models, 
    verbose = TRUE,
    metrics = yardstick::metric_set(yardstick::rmse, yardstick::rsq),
    fn = "fit_resamples",
    resamples = tbl_cv
  )
```

## Best model

```{r rank}
rank <- 
  workflowsets::rank_results(wset, rank_metric = "rmse", select_best = TRUE) |> 
  select(rank, wflow_id, model, .metric, mean) |> 
  filter(.metric == "rmse")
rank |> 
  gt::gt()
```

```{r assess, fig.height=5}
autoplot(wset) + theme_minimal()
```

```{r best}
tune_res <- 
  workflowsets::extract_workflow_set_result(
    wset, 
    id = rank$wflow_id[[1]]
  ) 
```

```{r finalize}
final_fit <- 
  wset |> 
  workflowsets::extract_workflow(id = rank$wflow_id[[1]]) |> 
  fit(data = tbl_train)
```

The following plots pertain **`r rank$wflow_id[[1]]`**.

## Assumptions

```{r check-assumptions}
lm_obj <- 
  final_fit |> 
  workflowsets::extract_fit_parsnip(id = rank$wflow_id[[1]])
plot_check <- performance::check_model(
  lm_obj, 
  check = c("linearity", "normality", "qq", "outliers"),
  theme = "ggplot2::theme_minimal"
  )
plot_check
```

```{r vif}
check_vif <- performance::check_collinearity(lm_obj)
plot(check_vif) +
  theme(axis.text.x = element_text(angle = 90))
```

## Parameters

```{r coeff-viz, fig.width=12}
coeff_df <- 
  final_fit |> 
  broom::tidy() 

coeff_df |> 
  mutate_is_significant(threshold = 0.05) |> 
  mutate(is_under_0.05 = forcats::fct_relevel(is_under_0.05, c("TRUE", "FALSE"))) |> 
  mutate(term = forcats::fct_relevel(term, sort)) |> 
  plot_coeff_table(.title = rank$wflow_id[[1]])
```
