---
title: "Explain Dx Gap"
output: html_document
date: "`r Sys.Date()`"
params:
  dm: dm
  data_tbl: data_tbl
  year: year
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(recipes)
pkgload::load_all()
knitr::opts_chunk$set(echo = FALSE, cache = TRUE, fig.align = "center", message = FALSE, warning = FALSE)
```

```{r params}
year <- params$year
data_tbl <- params$data_tbl
```

The chosen year is `r params$year`.

```{r data}
tbl <- 
  data_tbl |> 
  compute_dx_gap() |> 
  mutate(is_hbc = forcats::as_factor(is_hbc)) |> 
  select(-year, -country)
```

```{r recipes}
rec_core_pop_total <- get_core_recipe_pop_total(tbl, neighbors = 5)
rec_core_pop_density <- get_core_recipe_pop_density(tbl, neighbors = 5)
rec_log_pop_total <- get_log_recipe(rec_core_pop_total)
rec_log_pop_density <- get_log_recipe(rec_core_pop_density)
rec_norm_pop_total <- get_normalize_recipe(rec_core_pop_total)
rec_norm_pop_density <- get_normalize_recipe(rec_core_pop_density)
# rec_pop_100k <- get_pop_100k_recipe(rec_core)
rec_is_hbc_pop_total <- get_is_hbc_recipe(rec_core_pop_total)
rec_is_hbc_pop_density <- get_is_hbc_recipe(rec_core_pop_density)
```

```{r spending}
tbl_split <- rsample::initial_split(tbl)
tbl_train <- rsample::training(tbl_split)
tbl_test <- rsample::testing(tbl_split)
```

```{r cv}
set.seed(2023)
tbl_cv <- rsample::vfold_cv(tbl_train)
```

```{r show, eval=FALSE}
rec_core_pop_total |> 
  cook() |> 
  head() |> 
  gt::gt()
```

```{r lm}
lm_model <-
  parsnip::linear_reg(mode = "regression") %>%
  parsnip::set_engine("lm")
```

```{r combo}
models <- list(lm = lm_model)
preproc <- list(
  simple_pop_total = rec_core_pop_total,
  simple_pop_density = rec_core_pop_density,
  log_pop_total = rec_log_pop_total,
  log_pop_density = rec_log_pop_density,
  norm_pop_total = rec_norm_pop_total,
  norm_pop_density = rec_norm_pop_density,
  # pop_100k = rec_pop_100k, # FIXME: leads to high correlation features
  is_hbc_pop_total = rec_is_hbc_pop_total,
  is_hbc_pop_density = rec_is_hbc_pop_density
)
```

```{r set}
linear_models <- 
   workflowsets::workflow_set(
      preproc = preproc,
      models = models,
      cross = TRUE
   ) 
```

```{r fit}
wset <- 
  workflowsets::workflow_map(
    linear_models, 
    verbose = TRUE,
    metrics = yardstick::metric_set(yardstick::rmse, yardstick::rsq),
    fn = "fit_resamples",
    resamples = tbl_cv
  )
```

```{r rank}
rank <- 
  workflowsets::rank_results(wset, rank_metric = "rmse", select_best = TRUE) |> 
  select(rank, wflow_id, model, .metric, mean) |> 
  filter(.metric == "rmse")
rank |> 
  gt::gt()
```

```{r assess}
autoplot(wset)
```

```{r best}
tune_res <- 
  workflowsets::extract_workflow_set_result(
    wset, 
    id = rank$wflow_id[[1]]
  ) 
```

```{r finalize}
final_fit <- 
  wset |> 
  workflowsets::extract_workflow(id = rank$wflow_id[[1]]) |> 
  # tune::finalize_workflow() # TODO: use when fine tuning `neighbor`
  fit(data = tbl_train)
```

```{r coeff-viz, fig.width=15, fig.height=10}
coeff_df <- 
  final_fit |> 
  broom::tidy() 

coeff_df |> 
  mutate(is_significant = if_else(p.value < 0.05, TRUE, FALSE)) |> 
  mutate(term = forcats::fct_relevel(term, sort)) |> 
  ggplot(aes(term, estimate, color = is_significant)) +
  geom_point() +
  geom_pointrange(aes(ymin = estimate - std.error, ymax = estimate + std.error)) +
  scale_fill_manual(values = c("#CCEEFF", "#FFDDDD"), guide = "none") +
  coord_flip() +
  labs(title = rank$wflow_id[[1]]) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), axis.text.y = element_text(size = rel(1.25)))
```
