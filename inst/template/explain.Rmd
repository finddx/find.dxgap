---
title: "TB Policy Report"
output: html_document
date: "`r Sys.Date()`"
params:
  dm_hbc: dm_hbc
  dm_non_hbc: dm_non_hbc
  data_tbl: data_tbl
  year: year
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(recipes)
pkgload::load_all()
knitr::opts_chunk$set(echo = FALSE, cache = TRUE, fig.align = "center", message = FALSE, warning = FALSE)
```


```{r params}
year <- params$year
data_tbl <- params$data_tbl
```

The chosen year is `r params$year`.

```{r data}
tbl <- 
  data_tbl |> 
  mutate(who_dx_gap = (e_inc_num - c_newinc) / e_inc_num) 
```


```{r rec-core}
rec_core <-
  recipe(formula = who_dx_gap ~ ., x = tbl) |>
  update_role(who_dx_gap, new_role = "outcome") |>
  update_role(country_code, new_role = "id") |>
  step_filter_missing(all_predictors(), threshold = 0.9) |> 
  update_role(
    dplyr::all_of(
      c("c_cdr", "c_newinc_100k", "notified_ref_community", "notified_ref",
        "e_mort_100k", "e_pop_num", "new_labconf", "is_hbc")
    ),  
    new_role = "collinear"
  ) |>
  update_role(
    dplyr::all_of(c("pop_urban_perc", "pop_density")), 
    new_role = "no_norm"
  ) |>
  update_role(
    dplyr::all_of(
      c("e_inc_100k", "e_inc_num", "c_newinc", "pop_total", 
        "pop_density", "pop_urban_perc", "gdp")
    ),  
    new_role = "impute_w_median"
  ) |>
  step_filter(!if_any(c("gdp", "e_inc_num", "who_dx_gap", "pop_total"), is.na)) |> 
  step_impute_median(has_role("impute_w_median")) |> 
  step_mutate(pop_100k = pop_total / 1e5) |> 
  step_rm(has_role("collinear")) |>
  update_role(
    dplyr::all_of(c("gdp", "e_inc_num", "pop_total")), 
    new_role = "imputer_knn",
    old_role = "impute_w_median"
  ) |> 
  step_impute_knn(
    all_predictors(),
    neighbors = 5,
    impute_with = imp_vars(has_role("imputer_knn"))
  ) |>
  step_rm(e_inc_num, e_inc_100k, c_newinc) |> 
  step_mutate_at(
    all_numeric_predictors(), -has_role("no_norm"), fn = ~ .x / pop_100k
  ) |>
  step_zv(all_numeric_predictors()) 
```

```{r}
rec_core |> 
  cook() |> 
  skimr::skim()
```


```{r rec-log}
rec_log <- 
  rec_core |> 
  step_mutate_at(
    all_numeric_predictors(), fn = ~ dplyr::if_else(.x == 0, 1, .x)
  ) |> 
  step_log(all_numeric_predictors())
```


```{r lm}
lm_model <-
  parsnip::linear_reg(mode = "regression") %>%
  parsnip::set_engine("lm")
```

```{r lasso}
set.seed(2020)
lasso_model <- 
  parsnip::linear_reg(penalty = tune::tune(), mixture = 1) |> 
  parsnip::set_engine("glmnet")
lambda_grid <- dials::grid_regular(dials::penalty(), levels = 10)
# lasso_grid <- tune::tune_grid(lasso_model, grid = lambda_grid)
```


```{r eval=FALSE}
rec_core_prep <- prep(rec_core)
```

```{r}
models <- list(lm = lm_model, lasso = lasso_model)
preproc <- list(simple = rec_core, log = rec_log)
```

```{r set}
linear_models <- 
   workflowsets::workflow_set(
      preproc = preproc,
      models = models
   )
```

```{r spending}
tbl_split <- rsample::initial_split(tbl)
tbl_train <- rsample::training(tbl_split)
tbl_test <- rsample::testing(tbl_split)
```

```{r bootstrap}
tbl_boot <- rsample::bootstraps(tbl_train)
```


```{r fit}
fit <- 
  workflowsets::workflow_map(
    linear_models, 
    fn = "tune_grid",
    resamples = tbl_boot,
    grid = dials::grid_regular(dials::penalty(), levels = 10),
    verbose = TRUE
  ) 
```

```{r assess}
autoplot(fit)
```


```{r eval=FALSE}
wf <-
  workflows::workflow() |>
  workflows::add_model(lm_model) |>
  workflows::add_recipe(rec_core_prep) 
```

```{r eval=FALSE}
lm_fit <- parsnip::fit(linear_models, data = tbl)
```

```{r eval=FALSE}
lm_fit  |>
  workflows::extract_fit_parsnip() |>
  broom::tidy() |> 
  mutate(p.value = round(p.value, 3)) |> 
  gt::gt() |> 
  gt::data_color(
    rows = p.value < 0.05,
    palette = "red"
  )
```


