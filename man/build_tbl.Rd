% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dm.R
\name{build_tbl}
\alias{build_tbl}
\title{Load all data for a disease into a single wide table}
\usage{
build_tbl(disease, estimated = NULL, notified = NULL, year = NULL, vars = NULL)
}
\arguments{
\item{disease}{A character of length one identifying the disease for which
the user wants to build a wide table. The tibble \code{dxgap_diseases} shows the
diseases that are currently supported.}

\item{estimated}{Override the default \code{NULL} with a dot-separated character
indicating which field from which table should be used as estimated cases
for DX Gap computation. If kept to \code{NULL}, the function will use the value
\code{estimates_table.estimates_field} from the \code{notified} column in the
\code{dxgap_diseases} meta table.}

\item{notified}{Override the default \code{NULL} with a dot-separated character
indicating which field from which table should be used as notified cases
for DX Gap computation. If kept to \code{NULL}, the function will use the value
\code{notifications_table.notifications_field} from the \code{notified} column in the
\code{dxgap_diseases} meta table.}

\item{year}{An integer indicating a year to filter the data on. Defaults to
NULL, returning all years present in the data.}

\item{vars}{A vector of strings naming columns to subset the data on.
Defaults to NULL, indicating all variables should be used.}
}
\value{
A tibble.
}
\description{
\code{build_tbl()} loads all files for a given disease into a single dataframe. It
does this by flattening all of the tables into a single wide table by
performing a series of cascading joins on matching keys.
}
\examples{
\dontrun{
build_tbl(
  "tb",
  2019,
  estimated = "who_estimates.e_inc_num",
  notified = "who_notifications.c_newinc",
  c("year", "country", "pop_density", "e_inc_num", "c_newinc")
)
}
}
